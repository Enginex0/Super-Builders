From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
Subject: [PATCH] zeromount: add ADB port/socket/sysfs filter for untrusted_app

Adds a UID-gated filter hiding ADB presence from processes with UID
>= 10000 (untrusted_app). Controlled via sysfs:
  /sys/kernel/zeromount/hide_adb  (1 to enable, 0 to disable, default 0)

Written by post-fs-data.sh when hide_usb_debugging is enabled.
Root (uid 0), system (1000), shell (2000) always see real values.

---
 drivers/usb/gadget/configfs.c |  30 +++++++++++++
 fs/zeromount.c                |  30 +++++++++++++
 include/linux/zeromount.h     |   1 +
 net/ipv4/tcp_ipv4.c           |  22 ++++++++++
 net/ipv6/tcp_ipv6.c           |  22 ++++++++++
 net/unix/af_unix.c            |  29 +++++++++++++
 6 files changed, 134 insertions(+)

diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
index aaaaaaaaa..bbbbbbbbb 100644
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@ -1,6 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/configfs.h>
 #include <linux/module.h>
+#ifdef CONFIG_ZEROMOUNT
+#include <linux/zeromount.h>
+#include <linux/cred.h>
+#endif
 #include <linux/slab.h>
 #include <linux/device.h>
 #include <linux/nls.h>
@@ -689,1 +693,17 @@
-GS_STRINGS_RW(gadget_config_name, configuration);
+GS_STRINGS_W(gadget_config_name, configuration);
+#ifdef CONFIG_ZEROMOUNT
+static ssize_t gadget_config_name_configuration_show(struct config_item *item,
+						     char *page)
+{
+	struct gadget_config_name *gs = to_gadget_config_name(item);
+	if (atomic_read(&zeromount_hide_adb)) {
+		uid_t uid = from_kuid_munged(&init_user_ns, current_uid());
+		if (uid >= 10000)
+			return sprintf(page, "none\n");
+	}
+	return sprintf(page, "%s\n", gs->configuration ?: "");
+}
+#else
+GS_STRINGS_R(gadget_config_name, configuration);
+#endif
+CONFIGFS_ATTR(gadget_config_name_, configuration);
@@ -1753,5 +1773,13 @@ static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
 	char *state = "DISCONNECTED";
 	unsigned long flags;
 
+#ifdef CONFIG_ZEROMOUNT
+	if (atomic_read(&zeromount_hide_adb)) {
+		uid_t uid = from_kuid_munged(&init_user_ns, current_uid());
+		if (uid >= 10000)
+			return sprintf(buf, "DISCONNECTED\n");
+	}
+#endif
+
 	if (!dev)
 		goto out;
diff --git a/fs/zeromount.c b/fs/zeromount.c
index aaaaaaaaa..bbbbbbbbb 100644
--- a/fs/zeromount.c
+++ b/fs/zeromount.c
@@ -37,5 +37,7 @@ DEFINE_SPINLOCK(zeromount_lock);
 
 atomic_t zeromount_enabled = ATOMIC_INIT(0);
+atomic_t zeromount_hide_adb = ATOMIC_INIT(0);
+EXPORT_SYMBOL(zeromount_hide_adb);
 static atomic_t zeromount_dirs_count = ATOMIC_INIT(0);
 #define ZEROMOUNT_DISABLED() (atomic_read(&zeromount_enabled) == 0)
 
@@ -1393,7 +1395,30 @@ static struct kobj_attribute debug_attr =
 	__ATTR(debug, 0600, debug_show, debug_store);
 
+static ssize_t hide_adb_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	return sprintf(buf, "%d\n", atomic_read(&zeromount_hide_adb));
+}
+
+static ssize_t hide_adb_store(struct kobject *kobj, struct kobj_attribute *attr,
+			      const char *buf, size_t count)
+{
+	int val;
+
+	if (kstrtoint(buf, 10, &val) < 0)
+		return -EINVAL;
+	if (val < 0 || val > 1)
+		return -EINVAL;
+	atomic_set(&zeromount_hide_adb, val);
+	return count;
+}
+
+static struct kobj_attribute hide_adb_attr =
+	__ATTR(hide_adb, 0600, hide_adb_show, hide_adb_store);
+
 static struct attribute *zeromount_attrs[] = {
 	&debug_attr.attr,
+	&hide_adb_attr.attr,
 	NULL,
 };
 
diff --git a/include/linux/zeromount.h b/include/linux/zeromount.h
index aaaaaaaaa..bbbbbbbbb 100644
--- a/include/linux/zeromount.h
+++ b/include/linux/zeromount.h
@@ -149,5 +149,6 @@ extern spinlock_t zeromount_lock;
 #ifdef CONFIG_ZEROMOUNT
 extern atomic_t zeromount_enabled;
+extern atomic_t zeromount_hide_adb;
 
 bool zeromount_should_skip(void);
 char *zeromount_resolve_path(const char *pathname);
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index aaaaaaaaa..bbbbbbbbb 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -48,6 +48,9 @@
 #define pr_fmt(fmt) "TCP: " fmt
 
 #include <linux/bottom_half.h>
+#ifdef CONFIG_ZEROMOUNT
+#include <linux/zeromount.h>
+#endif
 #include <linux/types.h>
 #include <linux/fcntl.h>
 #include <linux/module.h>
@@ -2653,15 +2656,33 @@ static int tcp4_seq_show(struct seq_file *seq, void *v)
 {
 	struct tcp_iter_state *st;
 	struct sock *sk = v;
+#ifdef CONFIG_ZEROMOUNT
+	uid_t zm_uid;
+#endif
 
 	seq_setwidth(seq, TMPSZ - 1);
 	if (v == SEQ_START_TOKEN) {
 		seq_puts(seq, "  sl  local_address rem_address   st tx_queue "
 			   "rx_queue tr tm->when retrnsmt   uid  timeout "
 			   "inode");
 		goto out;
 	}
 	st = seq->private;
+
+#ifdef CONFIG_ZEROMOUNT
+	if (atomic_read(&zeromount_hide_adb)) {
+		zm_uid = from_kuid_munged(&init_user_ns, current_uid());
+		if (zm_uid >= 10000) {
+			if (sk->sk_state == TCP_TIME_WAIT) {
+				if (inet_twsk(sk)->tw_num == 5555)
+					return 0;
+			} else if (sk->sk_state != TCP_NEW_SYN_RECV) {
+				if (inet_sk(sk)->inet_num == 5555)
+					return 0;
+			}
+		}
+	}
+#endif
 
 	if (sk->sk_state == TCP_TIME_WAIT)
 		get_timewait4_sock(v, seq, st->num);
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index aaaaaaaaa..bbbbbbbbb 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -22,6 +22,9 @@
 #include <linux/bottom_half.h>
 #include <linux/module.h>
 #include <linux/errno.h>
+#ifdef CONFIG_ZEROMOUNT
+#include <linux/zeromount.h>
+#endif
 #include <linux/types.h>
 #include <linux/socket.h>
 #include <linux/sockios.h>
@@ -2070,17 +2073,35 @@ static int tcp6_seq_show(struct seq_file *seq, void *v)
 {
 	struct tcp_iter_state *st;
 	struct sock *sk = v;
+#ifdef CONFIG_ZEROMOUNT
+	uid_t zm_uid;
+#endif
 
 	if (v == SEQ_START_TOKEN) {
 		seq_puts(seq,
 			 "  sl  "
 			 "local_address                         "
 			 "remote_address                        "
 			 "st tx_queue rx_queue tr tm->when retrnsmt"
 			 "   uid  timeout inode\n");
 		goto out;
 	}
 	st = seq->private;
+
+#ifdef CONFIG_ZEROMOUNT
+	if (atomic_read(&zeromount_hide_adb)) {
+		zm_uid = from_kuid_munged(&init_user_ns, current_uid());
+		if (zm_uid >= 10000) {
+			if (sk->sk_state == TCP_TIME_WAIT) {
+				if (inet_twsk(sk)->tw_num == 5555)
+					return 0;
+			} else if (sk->sk_state != TCP_NEW_SYN_RECV) {
+				if (inet_sk(sk)->inet_num == 5555)
+					return 0;
+			}
+		}
+	}
+#endif
 
 	if (sk->sk_state == TCP_TIME_WAIT)
 		get_timewait6_sock(seq, v, st->num);
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index aaaaaaaaa..bbbbbbbbb 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -115,6 +115,9 @@
 #include <linux/file.h>
 
 #include "scm.h"
+#ifdef CONFIG_ZEROMOUNT
+#include <linux/zeromount.h>
+#endif
 
 struct hlist_head unix_socket_table[2 * UNIX_HASH_SIZE];
 EXPORT_SYMBOL_GPL(unix_socket_table);
@@ -2896,6 +2899,24 @@ static int unix_seq_show(struct seq_file *seq, void *v)
 	else {
 		struct sock *s = v;
 		struct unix_sock *u = unix_sk(s);
+
+#ifdef CONFIG_ZEROMOUNT
+		if (atomic_read(&zeromount_hide_adb)) {
+			uid_t uid = from_kuid_munged(&init_user_ns, current_uid());
+
+			if (uid >= 10000 && u->addr) {
+				const char *path = u->addr->name->sun_path;
+				int len = u->addr->len - sizeof(short);
+
+				if (!UNIX_ABSTRACT(s) && len > 0)
+					len--;
+				if (strnstr(path, "adbd", len) ||
+				    strnstr(path, "jdwp", len))
+					return 0;
+			}
+		}
+#endif
+
 		unix_state_lock(s);
 
 		seq_printf(seq, "%pK: %08X %08X %08X %04X %02X %5lu",
